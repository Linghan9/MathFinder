/*
 * EvaluatorMenu.cpp
 *
 *  Created on: Dec 14, 2016
 *      Author: jake
 */

#include <EvaluatorMenu.h>

#include <MainMenu.h>
#include <Evaluator.h>

#include <string>
#include <iostream>
#include <assert.h>

EvaluatorMenu::EvaluatorMenu(MainMenu* const back) {
  subMenus.push_back(back);
}

std::string EvaluatorMenu::getName() const {
  return "Evaluator Menu";
}

void EvaluatorMenu::doTask() {

  // Print explanation
  std::cout << "Evaluation can either be run on the result of a single group of one or "
      << "more images on which the finder was run (single result set), or on multiple such groups (result of multiple program runs). \n\n"
          "1. If done on a single group then the path to "
      << "a single results directory and single groundtruth directory must be specified. The results "
      << "directory should contain a single file ending with .rect which contains the results as well as the result images with foreground pixels colored "
      << "as indicated in the .rect file (with names as 0.png, 1.png, 2.png, etc). The "
      << "groundtruth directory must contain a .rect file which contains the groundtruth (in the format as generated by the provided groundtruth "
      << "generation gui in this application). The groundtruth "
      << "directory must also contain the original images on which the Math Finder was run along with the .rect file."

      << "\n\n2. If done on multiple groups (the output of multiple program runs), then the results "
      << "and groundtruth paths must be specified as previously mentioned but the results directory "
      << "must instead contain a subdirectory for each group containing the .rect file as previously mentioned. The groundtruth "
      << "directory must also contain subdirectories with the groundtruth for each group as previously defined.\n";

  // Select evaluation mode (single results set or multiple results set)
  std::cout << "Choose one of the below options:\n";
  const std::string singleRunOption = "Evaluate single run";
  const std::string multipleRunOption = "Evaluate multiple runs";
  std::string runOptionSelectionTmp = singleRunOption;
  {
    std::vector<std::string> runOptions;
    runOptions.push_back(singleRunOption);
    runOptions.push_back(multipleRunOption);
    runOptionSelectionTmp = runOptions[Utils::promptSelectStrFromLabeledMatrix(runOptions, 1)];
  }
  const std::string runOptionSelection = runOptionSelectionTmp;

  // Print explanation
  std::cout << "The evaluator will compare the results of a previous run of this application "
       << "to the groundtruth data in a specified directory. The groundtruth directory must contain "
       << "a .rect file which consists of the boundings boxes for all known math regions in the results and must also contain the original images. The results "
       << "directory consists of a .rect file in the same format with the results along with foreground pixel colored versions of the images for both display and pixel-accurate evaluation purposes. "
       << "The contents of these files are compared during evaluation.\n\n";

  // Select the paths holding the results to be evaluated and their groundtruths
  std::string resultsPath, groundtruthPath;
  std::cout << "Enter the results directory path: ";
  std::cin >> resultsPath;
  std::cout << "Enter the groundtruth directory path: ";
  std::cin >> groundtruthPath;

  // Select the types of math expressions to evaluate
  std::cout << "There are three possible types of data that can be evaluated "
      << " in this framework. These are as follows:\n"
      << "1. Displayed math expressions - math expressions residing on a separate, isolated row from other text blocks.\n"
      << "2. Embedded math expression - math expressions residing on the same row as other text residing within a text block.\n"
      << "3. Math expression label - a caption describing a math expression, usually appearing directly below a displayed expression.\n";
  std::cout << "\nSelect one of the layout evaluation options below:\n";
  const std::string mathNonMath = "Evaluate math vs non-math (lump options 1, 2, and 3 specified above together as one type during evaluation)";
  const std::string typeSpecific = "Evaluate types 1, 2, 3 specified above separately (each type above will have its own evaluation metrics)";
  std::string typeOptionSelectionTmp = mathNonMath;
  {
    std::vector<std::string> typeOptions;
    typeOptions.push_back(mathNonMath);
    typeOptions.push_back(typeSpecific);
    typeOptionSelectionTmp = typeOptions[Utils::promptSelectStrFromLabeledMatrix(typeOptions, 1)];
  }
  const bool typeSpecificMode = typeOptionSelectionTmp == mathNonMath ? false : true;

  // Carry out the selected evaluation
  if(runOptionSelection == singleRunOption) {
    Evaluator(resultsPath, groundtruthPath, typeSpecificMode).evaluateSingleRun();
  } else if(runOptionSelection == multipleRunOption) {
    std::cout << "Sorry, this option is not supported currently (and probably won't be.. my bad).\n";
    return;
    //Evaluator(resultsPath, groundtruthPath, typeSpecificMode).evaluateMultipleRuns();
  } else {
    std::cout << "ERROR: Unknown run option selected.\n";
    return;
  }
}
